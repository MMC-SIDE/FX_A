# チケット011: テスト実装

## 概要
システム全体の品質を保証するためのテストスイートを実装する。

## 目的
- バックエンドAPIの単体・統合テスト
- フロントエンドコンポーネントのテスト
- エンドツーエンドテスト
- パフォーマンステスト
- 継続的なテスト実行環境の構築

## 要件
- Pytest による Python テスト
- Jest/Testing Library による React テスト
- Playwright による E2E テスト
- テストカバレッジ 80% 以上
- CI/CD パイプライン対応

## 受け入れ基準
- [ ] バックエンド単体テスト
- [ ] バックエンド統合テスト
- [ ] フロントエンド単体テスト
- [ ] フロントエンド統合テスト
- [ ] E2Eテスト
- [ ] パフォーマンステスト

## 技術仕様

### バックエンドテスト設定
```python
# backend/tests/conftest.py
import pytest
import asyncio
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient
from unittest.mock import Mock

from backend.main import app
from backend.database import Base
from backend.core.mt5_client import MT5Client

# テスト用データベース
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture
def db_session():
    """テスト用データベースセッション"""
    Base.metadata.create_all(bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(bind=engine)

@pytest.fixture
def client():
    """FastAPIテストクライアント"""
    return TestClient(app)

@pytest.fixture
def mock_mt5_client():
    """MT5クライアントのモック"""
    mock = Mock(spec=MT5Client)
    mock.connect.return_value = True
    mock.get_rates.return_value = [
        {
            'time': '2023-01-01 00:00:00',
            'open': 130.00,
            'high': 130.50,
            'low': 129.50,
            'close': 130.25,
            'tick_volume': 1000
        }
    ]
    mock.get_tick.return_value = Mock(ask=130.25, bid=130.23)
    return mock

@pytest.fixture
def sample_price_data():
    """サンプル価格データ"""
    return pd.DataFrame({
        'time': pd.date_range('2023-01-01', periods=100, freq='H'),
        'open': np.random.normal(130, 1, 100),
        'high': np.random.normal(130.5, 1, 100),
        'low': np.random.normal(129.5, 1, 100),
        'close': np.random.normal(130, 1, 100),
        'tick_volume': np.random.randint(100, 1000, 100)
    })
```

### バックエンド単体テスト
```python
# backend/tests/test_mt5_client.py
import pytest
from unittest.mock import patch, Mock
from backend.core.mt5_client import MT5Client

class TestMT5Client:
    
    def test_connect_success(self, mock_mt5_client):
        """MT5接続成功テスト"""
        client = MT5Client("test_config.json")
        
        with patch('MetaTrader5.initialize', return_value=True):
            result = client.connect()
            assert result is True
    
    def test_connect_failure(self):
        """MT5接続失敗テスト"""
        client = MT5Client("invalid_config.json")
        
        with patch('MetaTrader5.initialize', return_value=False):
            result = client.connect()
            assert result is False
    
    def test_get_rates(self, mock_mt5_client):
        """価格データ取得テスト"""
        client = MT5Client("test_config.json")
        
        with patch('MetaTrader5.copy_rates_from_pos') as mock_rates:
            mock_rates.return_value = np.array([
                (1234567890, 130.00, 130.50, 129.50, 130.25, 1000, 0, 0)
            ], dtype=[('time', 'i8'), ('open', 'f8'), ('high', 'f8'), 
                     ('low', 'f8'), ('close', 'f8'), ('tick_volume', 'i8'),
                     ('spread', 'i4'), ('real_volume', 'i8')])
            
            rates = client.get_rates("USDJPY", mt5.TIMEFRAME_H1, 100)
            
            assert len(rates) == 1
            assert rates[0]['close'] == 130.25

# backend/tests/test_risk_manager.py
class TestRiskManager:
    
    def test_calculate_lot_size(self, db_session):
        """ロットサイズ計算テスト"""
        risk_manager = RiskManager(db_session)
        risk_manager.account_info = {
            'balance': 100000,
            'equity': 100000
        }
        risk_manager.settings = {
            'max_risk_per_trade': 2.0,
            'stop_loss_pips': 50
        }
        
        lot_size = risk_manager.calculate_lot_size("USDJPY", "BUY")
        
        # 2%リスク、50pips、pip値1000円で計算
        expected_lot_size = 2000 / (50 * 1000)  # 0.04
        assert abs(lot_size - expected_lot_size) < 0.01
    
    def test_check_risk_limits_success(self, db_session):
        """リスク制限チェック成功テスト"""
        risk_manager = RiskManager(db_session)
        risk_manager.account_info = {
            'balance': 100000,
            'equity': 100000,
            'margin_level': 300.0
        }
        
        assert risk_manager.check_risk_limits() is True
    
    def test_check_risk_limits_failure(self, db_session):
        """リスク制限チェック失敗テスト"""
        risk_manager = RiskManager(db_session)
        risk_manager.account_info = {
            'balance': 100000,
            'equity': 80000,
            'margin_level': 150.0  # 制限値以下
        }
        
        assert risk_manager.check_risk_limits() is False

# backend/tests/test_lightgbm_model.py
class TestLightGBMPredictor:
    
    def test_prepare_labels(self, sample_price_data):
        """ラベル作成テスト"""
        model = LightGBMPredictor()
        df_with_labels = model.prepare_labels(sample_price_data)
        
        assert 'label' in df_with_labels.columns
        assert 'future_return' in df_with_labels.columns
        assert df_with_labels['label'].isin([0, 1, 2]).all()
    
    def test_train_model(self, sample_price_data):
        """モデル学習テスト"""
        model = LightGBMPredictor()
        
        # 特徴量作成
        feature_engine = FeatureEngineering()
        features = feature_engine.create_features(sample_price_data)
        
        # ラベル作成
        labeled_data = model.prepare_labels(features)
        
        # NaN除去
        clean_data = labeled_data.dropna()
        
        if len(clean_data) > 50:  # 十分なデータがある場合
            X = clean_data.drop(['label', 'future_return'], axis=1)
            y = clean_data['label']
            
            metrics = model.train(X, y)
            
            assert 'accuracy' in metrics
            assert 'f1' in metrics
            assert model.model is not None
    
    def test_predict(self, sample_price_data):
        """予測テスト"""
        model = LightGBMPredictor()
        
        # モデルが学習済みの場合のテスト
        if model.model is not None:
            feature_engine = FeatureEngineering()
            features = feature_engine.create_features(sample_price_data.tail(10))
            
            predictions, confidence = model.predict(features)
            
            assert len(predictions) == len(features)
            assert len(confidence) == len(features)
            assert all(p in [0, 1, 2] for p in predictions)
```

### バックエンド統合テスト
```python
# backend/tests/test_api_integration.py
class TestTradingAPI:
    
    def test_start_trading_success(self, client, db_session):
        """取引開始APIテスト"""
        response = client.post("/api/v1/trading/start", json={
            "symbol": "USDJPY",
            "timeframe": "H1"
        })
        
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "started"
    
    def test_get_positions(self, client, db_session):
        """ポジション取得APIテスト"""
        # テストデータ挿入
        test_trade = Trade(
            symbol="USDJPY",
            order_type="BUY",
            entry_time=datetime.now(),
            entry_price=130.00,
            volume=0.1
        )
        db_session.add(test_trade)
        db_session.commit()
        
        response = client.get("/api/v1/positions")
        
        assert response.status_code == 200
        positions = response.json()
        assert len(positions) >= 0

class TestBacktestAPI:
    
    def test_run_backtest(self, client, db_session, sample_price_data):
        """バックテスト実行APIテスト"""
        # テスト用価格データをDBに保存
        for _, row in sample_price_data.iterrows():
            price_data = PriceData(
                symbol="USDJPY",
                timeframe="H1",
                time=row['time'],
                open=row['open'],
                high=row['high'],
                low=row['low'],
                close=row['close'],
                tick_volume=row['tick_volume']
            )
            db_session.add(price_data)
        db_session.commit()
        
        response = client.post("/api/v1/backtest/run", json={
            "symbol": "USDJPY",
            "timeframe": "H1",
            "start_date": "2023-01-01",
            "end_date": "2023-01-05",
            "parameters": {
                "risk_per_trade": 2.0,
                "stop_loss_pips": 50
            },
            "initial_balance": 100000
        })
        
        assert response.status_code == 200
        result = response.json()
        assert "test_id" in result
        assert "statistics" in result
```

### フロントエンドテスト設定
```javascript
// frontend/jest.config.js
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  dir: './',
})

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapping: {
    '^@/components/(.*)$': '<rootDir>/components/$1',
    '^@/hooks/(.*)$': '<rootDir>/hooks/$1',
    '^@/lib/(.*)$': '<rootDir>/lib/$1',
    '^@/store/(.*)$': '<rootDir>/store/$1',
    '^@/types/(.*)$': '<rootDir>/types/$1',
  },
  testEnvironment: 'jest-environment-jsdom',
  collectCoverageFrom: [
    'components/**/*.{ts,tsx}',
    'hooks/**/*.{ts,tsx}',
    'lib/**/*.{ts,tsx}',
    'store/**/*.{ts,tsx}',
    '!**/*.d.ts',
    '!**/*.stories.{ts,tsx}',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
}

module.exports = createJestConfig(customJestConfig)

// frontend/jest.setup.js
import '@testing-library/jest-dom'

// Mock Next.js router
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
    back: jest.fn(),
  }),
  useSearchParams: () => ({
    get: jest.fn(),
  }),
}))

// Mock WebSocket
global.WebSocket = jest.fn(() => ({
  close: jest.fn(),
  send: jest.fn(),
  addEventListener: jest.fn(),
  removeEventListener: jest.fn(),
}))
```

### フロントエンド単体テスト
```typescript
// frontend/__tests__/components/TradingPanel.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import TradingPanel from '@/components/trading/TradingPanel'

// テスト用のQueryClientを作成
const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false },
  },
})

const renderWithProviders = (component: React.ReactElement) => {
  const queryClient = createTestQueryClient()
  return render(
    <QueryClientProvider client={queryClient}>
      {component}
    </QueryClientProvider>
  )
}

describe('TradingPanel', () => {
  test('renders trading panel components', () => {
    renderWithProviders(<TradingPanel />)
    
    expect(screen.getByText('取引制御')).toBeInTheDocument()
    expect(screen.getByLabelText('通貨ペア')).toBeInTheDocument()
    expect(screen.getByLabelText('時間軸')).toBeInTheDocument()
    expect(screen.getByText('取引開始')).toBeInTheDocument()
  })
  
  test('changes symbol selection', async () => {
    renderWithProviders(<TradingPanel />)
    
    const symbolSelect = screen.getByLabelText('通貨ペア')
    fireEvent.mouseDown(symbolSelect)
    
    const eurjpyOption = await screen.findByText('EUR/JPY')
    fireEvent.click(eurjpyOption)
    
    expect(symbolSelect).toHaveValue('EURJPY')
  })
  
  test('starts trading when button clicked', async () => {
    // APIモック
    const mockMutate = jest.fn()
    jest.mock('@/hooks/useTrades', () => ({
      useStartTrading: () => ({
        mutate: mockMutate,
        isPending: false,
        error: null,
      }),
    }))
    
    renderWithProviders(<TradingPanel />)
    
    const startButton = screen.getByText('取引開始')
    fireEvent.click(startButton)
    
    await waitFor(() => {
      expect(mockMutate).toHaveBeenCalledWith({
        symbol: 'USDJPY',
        timeframe: 'H1'
      })
    })
  })
})

// frontend/__tests__/hooks/useTrades.test.tsx
import { renderHook, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useTrades } from '@/hooks/useTrades'

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  })
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}

describe('useTrades', () => {
  test('fetches trades data', async () => {
    // APIモック
    const mockTrades = [
      {
        id: '1',
        symbol: 'USDJPY',
        orderType: 'BUY',
        entryPrice: 130.00,
        profitLoss: 1000,
      },
    ]
    
    jest.spyOn(global, 'fetch').mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockTrades),
    } as Response)
    
    const { result } = renderHook(() => useTrades(), {
      wrapper: createWrapper(),
    })
    
    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true)
    })
    
    expect(result.current.data).toEqual(mockTrades)
  })
})
```

### E2Eテスト
```typescript
// frontend/e2e/trading.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Trading System E2E', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/')
  })
  
  test('can navigate to dashboard', async ({ page }) => {
    await page.click('text=ダッシュボード')
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('h4')).toContainText('ダッシュボード')
  })
  
  test('can start and stop trading', async ({ page }) => {
    await page.goto('/dashboard')
    
    // 取引開始
    await page.click('text=取引開始')
    await expect(page.locator('text=稼働中')).toBeVisible()
    
    // 取引停止
    await page.click('text=取引停止')
    await expect(page.locator('text=停止中')).toBeVisible()
  })
  
  test('can run backtest', async ({ page }) => {
    await page.goto('/backtest')
    
    // バックテスト設定
    await page.selectOption('[data-testid=symbol-select]', 'USDJPY')
    await page.selectOption('[data-testid=timeframe-select]', 'H1')
    await page.fill('[data-testid=start-date]', '2023-01-01')
    await page.fill('[data-testid=end-date]', '2023-12-31')
    
    // バックテスト実行
    await page.click('text=バックテスト実行')
    
    // 結果表示待機
    await expect(page.locator('[data-testid=backtest-results]')).toBeVisible({
      timeout: 30000,
    })
    
    // 統計データ確認
    await expect(page.locator('text=総取引回数')).toBeVisible()
    await expect(page.locator('text=勝率')).toBeVisible()
    await expect(page.locator('text=プロフィットファクター')).toBeVisible()
  })
  
  test('displays real-time data updates', async ({ page }) => {
    await page.goto('/dashboard')
    
    // WebSocket接続確認
    await expect(page.locator('[data-testid=connection-status]')).toContainText('接続中')
    
    // リアルタイムデータ更新確認（時間経過後にデータが変更されること）
    const initialValue = await page.locator('[data-testid=current-price]').textContent()
    
    // 5秒待機
    await page.waitForTimeout(5000)
    
    const updatedValue = await page.locator('[data-testid=current-price]').textContent()
    
    // データが更新されている可能性があることを確認
    // （実際の更新は市場状況による）
  })
})

// frontend/playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
})
```

### パフォーマンステスト
```python
# backend/tests/test_performance.py
import time
import asyncio
import pytest
from concurrent.futures import ThreadPoolExecutor

class TestPerformance:
    
    def test_api_response_time(self, client):
        """API応答時間テスト"""
        start_time = time.time()
        response = client.get("/api/v1/trading/status")
        end_time = time.time()
        
        assert response.status_code == 200
        assert (end_time - start_time) < 1.0  # 1秒以内
    
    def test_concurrent_requests(self, client):
        """同時リクエストテスト"""
        def make_request():
            return client.get("/api/v1/positions")
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(make_request) for _ in range(100)]
            results = [future.result() for future in futures]
        
        # 全てのリクエストが成功すること
        assert all(r.status_code == 200 for r in results)
    
    def test_memory_usage(self, sample_price_data):
        """メモリ使用量テスト"""
        import psutil
        import gc
        
        process = psutil.Process()
        initial_memory = process.memory_info().rss
        
        # 大量データ処理
        feature_engine = FeatureEngineering()
        for _ in range(10):
            features = feature_engine.create_features(sample_price_data)
        
        gc.collect()
        final_memory = process.memory_info().rss
        memory_increase = (final_memory - initial_memory) / 1024 / 1024  # MB
        
        # メモリ使用量増加が100MB以下であること
        assert memory_increase < 100
```

### テスト実行コマンド
```bash
# バックエンドテスト
cd backend
pip install pytest pytest-asyncio pytest-cov
pytest tests/ -v --cov=backend --cov-report=html

# フロントエンドテスト
cd frontend
npm test
npm run test:coverage
npm run test:e2e

# 全テスト実行
npm run test:all
```

### CI/CD設定
```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  backend-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v3
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-cov
      - name: Run tests
        run: |
          cd backend
          pytest tests/ --cov=backend --cov-report=xml
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: backend/coverage.xml

  frontend-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install dependencies
        run: |
          cd frontend
          npm ci
      - name: Run tests
        run: |
          cd frontend
          npm run test:coverage
      - name: E2E tests
        run: |
          cd frontend
          npm run build
          npm run start &
          npx playwright test
```

## テストカバレッジ目標
- **バックエンド**: 80%以上
- **フロントエンド**: 80%以上
- **E2Eテスト**: 主要ユーザーフロー100%

## 見積もり
**3日**

## 依存関係
- 全ての機能実装チケット

## 完了条件
- [ ] 全テストが正常に実行される
- [ ] テストカバレッジが目標値を上回る
- [ ] CI/CDパイプラインが動作する
- [ ] E2Eテストが成功する
- [ ] パフォーマンステストが通過する