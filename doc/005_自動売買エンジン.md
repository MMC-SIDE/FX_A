# チケット005: 自動売買エンジン

## 概要
LightGBMの予測結果に基づいてMT5で自動売買を実行するエンジンの実装。

## 目的
- 機械学習モデルの予測結果をトレードシグナルに変換
- MT5を通じた自動注文執行
- ポジション管理（エントリー・エグジット）
- リアルタイム監視とアラート機能

## 要件
- ML予測結果の解釈とシグナル生成
- MT5での自動注文実行
- ポジション管理とトラッキング
- ナンピン機能の実装
- 緊急停止機能

## 受け入れ基準
- [×] トレーディングエンジンクラスの実装
- [×] シグナル生成ロジックの実装
- [×] MT5注文実行機能
- [×] ポジション管理機能
- [×] ナンピンロジックの実装
- [×] 緊急停止・エラーハンドリング

## 技術仕様

### トレーディングエンジン
```python
# backend/core/trading_engine.py
class TradingEngine:
    def __init__(self, mt5_client: MT5Client, 
                 risk_manager: RiskManager,
                 model_manager: ModelManager):
        self.mt5 = mt5_client
        self.risk_manager = risk_manager
        self.model_manager = model_manager
        self.is_active = False
        self.current_positions = {}
        
    def start_trading(self, symbol: str, timeframe: str):
        """自動売買開始"""
        self.is_active = True
        self.symbol = symbol
        self.timeframe = timeframe
        
        # モデル読み込み
        self.model = self.model_manager.load_latest_model(symbol, timeframe)
        if not self.model:
            raise ValueError(f"No trained model found for {symbol} {timeframe}")
        
        logger.info(f"Trading started for {symbol} {timeframe}")
        
        # メインループ開始
        asyncio.create_task(self._trading_loop())
    
    def stop_trading(self):
        """自動売買停止"""
        self.is_active = False
        logger.info("Trading stopped")
    
    async def _trading_loop(self):
        """メイントレーディングループ"""
        while self.is_active:
            try:
                # 最新データ取得
                latest_data = await self._get_latest_data()
                
                # 予測実行
                signal, confidence = await self._generate_signal(latest_data)
                
                # リスクチェック
                if not self.risk_manager.check_risk_limits():
                    logger.warning("Risk limits exceeded, skipping trade")
                    await asyncio.sleep(60)
                    continue
                
                # トレード実行
                await self._execute_trade_signal(signal, confidence)
                
                # ポジション管理
                await self._manage_positions()
                
                # 次の実行まで待機
                await asyncio.sleep(self._get_check_interval())
                
            except Exception as e:
                logger.error(f"Trading loop error: {e}")
                await asyncio.sleep(60)  # エラー時は1分待機
    
    async def _generate_signal(self, data: pd.DataFrame) -> tuple:
        """シグナル生成"""
        # 特徴量作成
        features = self.feature_engineering.create_features(data)
        
        # 予測実行
        predictions, confidence = self.model.predict(features.tail(1))
        
        # シグナル変換
        signal_map = {0: 'HOLD', 1: 'BUY', 2: 'SELL'}
        signal = signal_map[predictions[0]]
        
        logger.info(f"Generated signal: {signal} (confidence: {confidence[0]:.3f})")
        
        return signal, confidence[0]
    
    async def _execute_trade_signal(self, signal: str, confidence: float):
        """トレードシグナル実行"""
        min_confidence = 0.7  # 最小信頼度
        
        if confidence < min_confidence:
            logger.info(f"Signal confidence too low: {confidence:.3f}")
            return
        
        current_position = self.current_positions.get(self.symbol)
        
        if signal == 'BUY':
            if not current_position or current_position['type'] == 'SELL':
                await self._open_position('BUY')
        elif signal == 'SELL':
            if not current_position or current_position['type'] == 'BUY':
                await self._open_position('SELL')
        # HOLDの場合は何もしない
    
    async def _open_position(self, order_type: str):
        """ポジションオープン"""
        try:
            # 既存ポジションがあればクローズ
            if self.symbol in self.current_positions:
                await self._close_position(self.symbol)
            
            # ロットサイズ計算
            lot_size = self.risk_manager.calculate_lot_size(
                self.symbol, 
                order_type
            )
            
            # 価格取得
            tick = self.mt5.get_tick(self.symbol)
            price = tick.ask if order_type == 'BUY' else tick.bid
            
            # ストップロス・テイクプロフィット計算
            sl, tp = self.risk_manager.calculate_sl_tp(
                self.symbol, 
                order_type, 
                price
            )
            
            # 注文実行
            order_result = self.mt5.place_order(
                symbol=self.symbol,
                order_type=order_type,
                volume=lot_size,
                price=price,
                sl=sl,
                tp=tp,
                comment=f"ML_AUTO_{self.timeframe}"
            )
            
            if order_result.retcode == mt5.TRADE_RETCODE_DONE:
                # ポジション記録
                position_data = {
                    'order_id': order_result.order,
                    'type': order_type,
                    'volume': lot_size,
                    'open_price': price,
                    'open_time': datetime.now(),
                    'sl': sl,
                    'tp': tp,
                    'nanpin_count': 0
                }
                self.current_positions[self.symbol] = position_data
                
                # DB保存
                await self._save_trade_to_db(position_data)
                
                logger.info(f"Position opened: {order_type} {lot_size} lots at {price}")
            else:
                logger.error(f"Order failed: {order_result.comment}")
                
        except Exception as e:
            logger.error(f"Error opening position: {e}")
    
    async def _close_position(self, symbol: str):
        """ポジションクローズ"""
        if symbol not in self.current_positions:
            return
        
        position = self.current_positions[symbol]
        
        try:
            # クローズ注文実行
            close_result = self.mt5.close_position(position['order_id'])
            
            if close_result.retcode == mt5.TRADE_RETCODE_DONE:
                # 損益計算
                tick = self.mt5.get_tick(symbol)
                close_price = tick.bid if position['type'] == 'BUY' else tick.ask
                
                # ポジション削除
                del self.current_positions[symbol]
                
                # DB更新
                await self._update_trade_in_db(
                    position['order_id'], 
                    close_price, 
                    datetime.now()
                )
                
                logger.info(f"Position closed: {symbol} at {close_price}")
            else:
                logger.error(f"Close failed: {close_result.comment}")
                
        except Exception as e:
            logger.error(f"Error closing position: {e}")
```

### ナンピン機能
```python
class NanpinManager:
    def __init__(self, max_count: int = 3, interval_pips: int = 10):
        self.max_count = max_count
        self.interval_pips = interval_pips
    
    async def check_nanpin_condition(self, symbol: str, 
                                   position: dict) -> bool:
        """ナンピン条件チェック"""
        if position['nanpin_count'] >= self.max_count:
            return False
        
        # 現在価格取得
        tick = self.mt5.get_tick(symbol)
        current_price = tick.ask if position['type'] == 'BUY' else tick.bid
        
        # 価格差計算
        price_diff = abs(current_price - position['open_price'])
        pip_diff = price_diff * 10000  # USDJPYの場合
        
        # ナンピン実行条件
        if position['type'] == 'BUY' and current_price < position['open_price']:
            return pip_diff >= self.interval_pips
        elif position['type'] == 'SELL' and current_price > position['open_price']:
            return pip_diff >= self.interval_pips
        
        return False
    
    async def execute_nanpin(self, symbol: str, position: dict):
        """ナンピン実行"""
        # 追加ロットサイズ（同じサイズ）
        additional_volume = position['volume']
        
        # 現在価格で追加注文
        tick = self.mt5.get_tick(symbol)
        price = tick.ask if position['type'] == 'BUY' else tick.bid
        
        order_result = self.mt5.place_order(
            symbol=symbol,
            order_type=position['type'],
            volume=additional_volume,
            price=price,
            comment=f"NANPIN_{position['nanpin_count'] + 1}"
        )
        
        if order_result.retcode == mt5.TRADE_RETCODE_DONE:
            # ポジション情報更新（平均価格計算）
            total_volume = position['volume'] + additional_volume
            avg_price = (
                (position['open_price'] * position['volume'] + 
                 price * additional_volume) / total_volume
            )
            
            position['volume'] = total_volume
            position['open_price'] = avg_price
            position['nanpin_count'] += 1
            
            logger.info(f"Nanpin executed: {position['nanpin_count']}/{self.max_count}")
```

### リスク管理統合
```python
async def _manage_positions(self):
    """ポジション管理"""
    for symbol, position in self.current_positions.copy().items():
        # 緊急停止チェック
        if self.risk_manager.should_emergency_stop():
            await self._close_position(symbol)
            continue
        
        # ナンピンチェック
        if self.risk_manager.settings.get('use_nanpin', False):
            if await self.nanpin_manager.check_nanpin_condition(symbol, position):
                await self.nanpin_manager.execute_nanpin(symbol, position)
        
        # トレーリングストップチェック
        await self._check_trailing_stop(symbol, position)
```

## API インターフェース
```python
# FastAPI エンドポイント
@app.post("/api/v1/trading/start")
async def start_trading(symbol: str, timeframe: str):
    """自動売買開始"""
    
@app.post("/api/v1/trading/stop")
async def stop_trading():
    """自動売買停止"""
    
@app.get("/api/v1/trading/status")
async def get_trading_status():
    """取引状態取得"""
    
@app.get("/api/v1/positions")
async def get_current_positions():
    """現在のポジション取得"""
```

## 安全機能
- 最大ドローダウン監視
- 連続損失回数制限
- 緊急停止機能
- 接続断時の自動停止

## 見積もり
**4日**

## 依存関係
- チケット002: MT5データ取得機能
- チケット004: LightGBM機械学習エンジン
- チケット006: リスク管理機能

## 完了条件
- [×] 自動売買が正常に動作する
- [×] ポジション管理が適切に行われる
- [×] ナンピン機能が動作する
- [×] 緊急停止機能が動作する
- [×] エラー時の安全な停止が確認される