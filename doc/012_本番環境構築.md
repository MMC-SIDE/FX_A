# チケット012: 本番環境構築

## 概要
本番環境での安定運用のためのインフラ構築とデプロイメント設定。

## 目的
- 本番環境での安定運用
- セキュリティの確保
- 監視・ログ管理の実装
- 自動デプロイメントの構築
- 災害復旧対策

## 要件
- Docker による コンテナ化
- HTTPS通信の設定
- データベースバックアップ
- 監視・アラート設定
- ログ管理システム

## 受け入れ基準
- [ ] Docker構成の実装
- [ ] HTTPS/SSL設定
- [ ] データベースバックアップ自動化
- [ ] 監視システム設定
- [ ] ログ管理システム
- [ ] 自動デプロイメント設定

## 技術仕様

### Docker構成
```dockerfile
# backend/Dockerfile
FROM python:3.9-slim

WORKDIR /app

# システム依存関係
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# Python依存関係
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# アプリケーションコード
COPY . .

# 非rootユーザー作成
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

# frontend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000
ENV PORT 3000

CMD ["node", "server.js"]
```

### Docker Compose設定
```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  backend:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    container_name: fx_backend
    restart: unless-stopped
    environment:
      - DATABASE_URL=postgresql://fx_user:${DB_PASSWORD}@postgres:5432/fx_trading
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - MT5_CONFIG_PATH=/app/config/mt5_config.json
    volumes:
      - ./config:/app/config:ro
      - ./logs:/app/logs
      - ./data:/app/data
    depends_on:
      - postgres
      - redis
    networks:
      - fx_network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: fx_frontend
    restart: unless-stopped
    environment:
      - NEXT_PUBLIC_API_URL=https://api.fx-trading.local
    networks:
      - fx_network

  postgres:
    image: timescale/timescaledb:latest-pg14
    container_name: fx_postgres
    restart: unless-stopped
    environment:
      - POSTGRES_DB=fx_trading
      - POSTGRES_USER=fx_user
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
      - ./backups:/backups
    networks:
      - fx_network

  redis:
    image: redis:7-alpine
    container_name: fx_redis
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    networks:
      - fx_network

  nginx:
    image: nginx:alpine
    container_name: fx_nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
      - ./logs/nginx:/var/log/nginx
    depends_on:
      - backend
      - frontend
    networks:
      - fx_network

  celery:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: fx_celery
    restart: unless-stopped
    command: celery -A tasks worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql://fx_user:${DB_PASSWORD}@postgres:5432/fx_trading
      - REDIS_URL=redis://redis:6379
    volumes:
      - ./config:/app/config:ro
      - ./logs:/app/logs
      - ./data:/app/data
    depends_on:
      - postgres
      - redis
    networks:
      - fx_network

  prometheus:
    image: prom/prometheus:latest
    container_name: fx_prometheus
    restart: unless-stopped
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - fx_network

  grafana:
    image: grafana/grafana:latest
    container_name: fx_grafana
    restart: unless-stopped
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    ports:
      - "3001:3000"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
    networks:
      - fx_network

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:

networks:
  fx_network:
    driver: bridge
```

### Nginx設定
```nginx
# nginx/nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream backend {
        server backend:8000;
    }

    upstream frontend {
        server frontend:3000;
    }

    # HTTPからHTTPSへのリダイレクト
    server {
        listen 80;
        server_name fx-trading.local;
        return 301 https://$server_name$request_uri;
    }

    # メインサイト
    server {
        listen 443 ssl http2;
        server_name fx-trading.local;

        # SSL設定
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;

        # セキュリティヘッダー
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";

        # フロントエンド
        location / {
            proxy_pass http://frontend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # WebSocket
        location /ws/ {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }

    # API サーバー
    server {
        listen 443 ssl http2;
        server_name api.fx-trading.local;

        # SSL設定（同上）
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;

        # セキュリティヘッダー
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";

        # API
        location / {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # CORS設定
            add_header Access-Control-Allow-Origin "https://fx-trading.local";
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "Content-Type, Authorization";
        }
    }

    # ログ設定
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;
}
```

### 環境変数設定
```bash
# .env.prod
# データベース
DB_PASSWORD=your_secure_db_password
REDIS_PASSWORD=your_secure_redis_password

# JWT
JWT_SECRET=your_jwt_secret_key

# Grafana
GRAFANA_PASSWORD=your_grafana_password

# MT5設定
MT5_LOGIN=your_mt5_login
MT5_PASSWORD=your_mt5_password
MT5_SERVER=your_mt5_server

# 外部API
ECONOMIC_NEWS_API_KEY=your_api_key

# アラート通知
SLACK_WEBHOOK_URL=your_slack_webhook
EMAIL_SMTP_HOST=smtp.gmail.com
EMAIL_SMTP_PORT=587
EMAIL_USERNAME=your_email
EMAIL_PASSWORD=your_email_password
```

### データベースバックアップ
```bash
#!/bin/bash
# scripts/backup_database.sh

# 設定
DB_CONTAINER="fx_postgres"
DB_NAME="fx_trading"
DB_USER="fx_user"
BACKUP_DIR="/backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="fx_trading_backup_${DATE}.sql"

# バックアップ実行
docker exec $DB_CONTAINER pg_dump -U $DB_USER -d $DB_NAME > "${BACKUP_DIR}/${BACKUP_FILE}"

# 圧縮
gzip "${BACKUP_DIR}/${BACKUP_FILE}"

# 古いバックアップを削除（30日以上古いもの）
find $BACKUP_DIR -name "fx_trading_backup_*.sql.gz" -mtime +30 -delete

echo "Database backup completed: ${BACKUP_FILE}.gz"

# crontabに追加
# 0 2 * * * /path/to/scripts/backup_database.sh
```

### 監視設定
```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'backend'
    static_configs:
      - targets: ['backend:8000']
    metrics_path: '/metrics'

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres:5432']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']

  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx:80']

rule_files:
  - "alert_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

### アプリケーション監視
```python
# backend/monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge, generate_latest
import time

# メトリクス定義
REQUEST_COUNT = Counter('fx_requests_total', 'Total requests', ['method', 'endpoint'])
REQUEST_DURATION = Histogram('fx_request_duration_seconds', 'Request duration')
ACTIVE_TRADES = Gauge('fx_active_trades', 'Number of active trades')
CURRENT_BALANCE = Gauge('fx_current_balance', 'Current account balance')
SYSTEM_ERRORS = Counter('fx_system_errors_total', 'System errors', ['error_type'])

class MetricsMiddleware:
    def __init__(self, app):
        self.app = app
    
    async def __call__(self, scope, receive, send):
        if scope["type"] == "http":
            start_time = time.time()
            
            # リクエストカウント
            method = scope["method"]
            path = scope["path"]
            REQUEST_COUNT.labels(method=method, endpoint=path).inc()
            
            # レスポンス処理
            response = await self.app(scope, receive, send)
            
            # レスポンス時間記録
            duration = time.time() - start_time
            REQUEST_DURATION.observe(duration)
            
            return response
        else:
            return await self.app(scope, receive, send)

# FastAPIアプリに統合
@app.middleware("http")
async def add_metrics_middleware(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    REQUEST_DURATION.observe(process_time)
    REQUEST_COUNT.labels(
        method=request.method, 
        endpoint=request.url.path
    ).inc()
    return response

@app.get("/metrics")
async def metrics():
    """Prometheusメトリクス"""
    return Response(generate_latest(), media_type="text/plain")
```

### ログ管理
```python
# backend/logging_config.py
import logging
import logging.handlers
from pathlib import Path

def setup_logging():
    """ログ設定"""
    
    # ログディレクトリ作成
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    
    # ログフォーマット
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # ルートロガー設定
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    
    # ファイルハンドラー（アプリケーションログ）
    app_handler = logging.handlers.RotatingFileHandler(
        log_dir / "app.log",
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    app_handler.setFormatter(formatter)
    app_handler.setLevel(logging.INFO)
    
    # エラーログハンドラー
    error_handler = logging.handlers.RotatingFileHandler(
        log_dir / "error.log",
        maxBytes=10*1024*1024,
        backupCount=5
    )
    error_handler.setFormatter(formatter)
    error_handler.setLevel(logging.ERROR)
    
    # 取引ログハンドラー
    trading_logger = logging.getLogger("trading")
    trading_handler = logging.handlers.RotatingFileHandler(
        log_dir / "trading.log",
        maxBytes=10*1024*1024,
        backupCount=10
    )
    trading_handler.setFormatter(formatter)
    trading_logger.addHandler(trading_handler)
    trading_logger.setLevel(logging.INFO)
    
    # ハンドラー追加
    root_logger.addHandler(app_handler)
    root_logger.addHandler(error_handler)
    
    # 本番環境ではコンソールログを無効化
    if not logging.getLogger().handlers:
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        root_logger.addHandler(console_handler)
```

### デプロイメントスクリプト
```bash
#!/bin/bash
# scripts/deploy.sh

set -e

echo "Starting deployment..."

# 環境変数読み込み
source .env.prod

# Gitから最新コード取得
git pull origin main

# Dockerイメージビルド
docker-compose -f docker-compose.prod.yml build

# データベースマイグレーション
docker-compose -f docker-compose.prod.yml run --rm backend alembic upgrade head

# サービス再起動（ダウンタイムなし）
docker-compose -f docker-compose.prod.yml up -d

# ヘルスチェック
echo "Waiting for services to start..."
sleep 30

# バックエンドヘルスチェック
if curl -f http://localhost/api/v1/health; then
    echo "Backend health check passed"
else
    echo "Backend health check failed"
    exit 1
fi

# フロントエンドヘルスチェック
if curl -f http://localhost; then
    echo "Frontend health check passed"
else
    echo "Frontend health check failed"
    exit 1
fi

echo "Deployment completed successfully"

# Slackに通知
curl -X POST -H 'Content-type: application/json' \
    --data '{"text":"FX Trading System deployed successfully"}' \
    $SLACK_WEBHOOK_URL
```

### セキュリティ設定
```python
# backend/security/security.py
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
import os

class SecurityManager:
    def __init__(self):
        self.encryption_key = os.environ.get('ENCRYPTION_KEY') or Fernet.generate_key()
        self.cipher_suite = Fernet(self.encryption_key)
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """機密データの暗号化"""
        return self.cipher_suite.encrypt(data.encode()).decode()
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """機密データの復号化"""
        return self.cipher_suite.decrypt(encrypted_data.encode()).decode()
    
    def hash_password(self, password: str) -> str:
        """パスワードハッシュ化"""
        from passlib.context import CryptContext
        pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        return pwd_context.hash(password)
    
    def verify_password(self, password: str, hashed: str) -> bool:
        """パスワード検証"""
        from passlib.context import CryptContext
        pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        return pwd_context.verify(password, hashed)
```

### SSL証明書設定
```bash
# scripts/setup_ssl.sh
#!/bin/bash

# Let's Encrypt SSL証明書取得
# 本番環境では実際のドメインを使用

# 開発・テスト用の自己署名証明書
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout nginx/ssl/key.pem \
    -out nginx/ssl/cert.pem \
    -subj "/C=JP/ST=Tokyo/L=Tokyo/O=FX Trading/CN=fx-trading.local"

echo "SSL certificates generated"
```

## セキュリティチェックリスト
- [ ] 全ての機密情報を環境変数で管理
- [ ] データベース接続の暗号化
- [ ] HTTPS通信の強制
- [ ] APIアクセス制限
- [ ] ログの機密情報マスキング
- [ ] 定期的なセキュリティ更新

## 見積もり
**4日**

## 依存関係
- 全ての機能実装チケット

## 完了条件
- [ ] Docker環境が正常に動作する
- [ ] HTTPS通信が確立される
- [ ] データベースバックアップが自動実行される
- [ ] 監視システムが動作する
- [ ] ログが適切に記録される
- [ ] 自動デプロイメントが成功する