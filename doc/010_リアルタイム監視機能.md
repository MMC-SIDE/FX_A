# チケット010: リアルタイム監視機能

## 概要
システムの稼働状況、取引状況、リスク状況をリアルタイムで監視する機能の実装。

## 目的
- システム異常の早期検出
- 取引状況のリアルタイム把握
- リスク状況の常時監視
- アラート通知機能

## 要件
- WebSocketによるリアルタイム通信
- システムヘルスチェック
- 取引状況監視
- リスクアラート機能
- ログ管理とビューア

## 受け入れ基準
- [ ] WebSocketサーバーの実装
- [ ] システム監視機能
- [ ] リアルタイムダッシュボード
- [ ] アラート通知システム
- [ ] ログビューア機能
- [ ] パフォーマンス監視

## 技術仕様

### WebSocketサーバー
```python
# backend/websocket/websocket_manager.py
from fastapi import WebSocket, WebSocketDisconnect
from typing import List, Dict
import asyncio
import json
import logging

class WebSocketManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.connection_data: Dict[WebSocket, dict] = {}
        
    async def connect(self, websocket: WebSocket, client_data: dict = None):
        """WebSocket接続"""
        await websocket.accept()
        self.active_connections.append(websocket)
        self.connection_data[websocket] = client_data or {}
        
        logger.info(f"WebSocket connected: {client_data}")
        
        # 接続時に初期データ送信
        await self.send_initial_data(websocket)
    
    def disconnect(self, websocket: WebSocket):
        """WebSocket切断"""
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
            del self.connection_data[websocket]
            logger.info("WebSocket disconnected")
    
    async def send_personal_message(self, message: dict, websocket: WebSocket):
        """個別メッセージ送信"""
        try:
            await websocket.send_text(json.dumps(message))
        except Exception as e:
            logger.error(f"Failed to send message: {e}")
            self.disconnect(websocket)
    
    async def broadcast(self, message: dict):
        """全接続にブロードキャスト"""
        if not self.active_connections:
            return
            
        # 切断された接続を除去
        valid_connections = []
        
        for connection in self.active_connections:
            try:
                await connection.send_text(json.dumps(message))
                valid_connections.append(connection)
            except Exception as e:
                logger.error(f"Failed to send broadcast: {e}")
                self.disconnect(connection)
        
        self.active_connections = valid_connections
    
    async def send_initial_data(self, websocket: WebSocket):
        """初期データ送信"""
        try:
            # システム状況
            system_status = await self._get_system_status()
            await self.send_personal_message({
                'type': 'system_status',
                'data': system_status
            }, websocket)
            
            # 取引状況
            trading_status = await self._get_trading_status()
            await self.send_personal_message({
                'type': 'trading_status',
                'data': trading_status
            }, websocket)
            
        except Exception as e:
            logger.error(f"Failed to send initial data: {e}")

# WebSocketマネージャーのインスタンス
websocket_manager = WebSocketManager()
```

### システム監視機能
```python
# backend/monitoring/system_monitor.py
import psutil
import asyncio
from datetime import datetime, timedelta
import logging

class SystemMonitor:
    def __init__(self, websocket_manager: WebSocketManager):
        self.websocket_manager = websocket_manager
        self.monitoring_active = False
        self.alert_thresholds = {
            'cpu_percent': 80.0,
            'memory_percent': 85.0,
            'disk_percent': 90.0,
            'connection_errors': 5
        }
        
    async def start_monitoring(self):
        """監視開始"""
        self.monitoring_active = True
        logger.info("System monitoring started")
        
        # バックグラウンドタスクとして監視実行
        asyncio.create_task(self._monitoring_loop())
        asyncio.create_task(self._mt5_connection_monitor())
        asyncio.create_task(self._database_monitor())
        asyncio.create_task(self._trading_monitor())
    
    def stop_monitoring(self):
        """監視停止"""
        self.monitoring_active = False
        logger.info("System monitoring stopped")
    
    async def _monitoring_loop(self):
        """メイン監視ループ"""
        while self.monitoring_active:
            try:
                # システムリソース取得
                system_stats = self._get_system_stats()
                
                # WebSocketで送信
                await self.websocket_manager.broadcast({
                    'type': 'system_stats',
                    'timestamp': datetime.now().isoformat(),
                    'data': system_stats
                })
                
                # アラートチェック
                await self._check_system_alerts(system_stats)
                
                # 30秒間隔
                await asyncio.sleep(30)
                
            except Exception as e:
                logger.error(f"Monitoring loop error: {e}")
                await asyncio.sleep(60)
    
    def _get_system_stats(self) -> dict:
        """システム統計取得"""
        # CPU使用率
        cpu_percent = psutil.cpu_percent(interval=1)
        
        # メモリ使用率
        memory = psutil.virtual_memory()
        memory_percent = memory.percent
        
        # ディスク使用率
        disk = psutil.disk_usage('/')
        disk_percent = disk.percent
        
        # ネットワーク統計
        network = psutil.net_io_counters()
        
        return {
            'cpu_percent': round(cpu_percent, 2),
            'memory_percent': round(memory_percent, 2),
            'memory_available_gb': round(memory.available / (1024**3), 2),
            'disk_percent': round(disk_percent, 2),
            'disk_free_gb': round(disk.free / (1024**3), 2),
            'network_sent_mb': round(network.bytes_sent / (1024**2), 2),
            'network_recv_mb': round(network.bytes_recv / (1024**2), 2)
        }
    
    async def _check_system_alerts(self, stats: dict):
        """システムアラートチェック"""
        alerts = []
        
        # CPU使用率チェック
        if stats['cpu_percent'] > self.alert_thresholds['cpu_percent']:
            alerts.append({
                'level': 'warning',
                'type': 'high_cpu',
                'message': f"CPU使用率が高いです: {stats['cpu_percent']:.1f}%",
                'value': stats['cpu_percent']
            })
        
        # メモリ使用率チェック
        if stats['memory_percent'] > self.alert_thresholds['memory_percent']:
            alerts.append({
                'level': 'warning',
                'type': 'high_memory',
                'message': f"メモリ使用率が高いです: {stats['memory_percent']:.1f}%",
                'value': stats['memory_percent']
            })
        
        # ディスク使用率チェック
        if stats['disk_percent'] > self.alert_thresholds['disk_percent']:
            alerts.append({
                'level': 'error',
                'type': 'high_disk',
                'message': f"ディスク使用率が高いです: {stats['disk_percent']:.1f}%",
                'value': stats['disk_percent']
            })
        
        # アラートがあれば送信
        if alerts:
            await self.websocket_manager.broadcast({
                'type': 'system_alerts',
                'timestamp': datetime.now().isoformat(),
                'alerts': alerts
            })
    
    async def _mt5_connection_monitor(self):
        """MT5接続監視"""
        while self.monitoring_active:
            try:
                # MT5接続状態チェック
                mt5_status = await self._check_mt5_connection()
                
                await self.websocket_manager.broadcast({
                    'type': 'mt5_status',
                    'timestamp': datetime.now().isoformat(),
                    'data': mt5_status
                })
                
                # 接続エラー時のアラート
                if not mt5_status['connected']:
                    await self.websocket_manager.broadcast({
                        'type': 'system_alerts',
                        'timestamp': datetime.now().isoformat(),
                        'alerts': [{
                            'level': 'error',
                            'type': 'mt5_disconnected',
                            'message': 'MT5との接続が切断されました',
                            'value': False
                        }]
                    })
                
                await asyncio.sleep(10)  # 10秒間隔
                
            except Exception as e:
                logger.error(f"MT5 monitoring error: {e}")
                await asyncio.sleep(30)
    
    async def _check_mt5_connection(self) -> dict:
        """MT5接続状態チェック"""
        try:
            # MT5クライアントから接続状態取得
            # 実装はMT5Clientクラスに依存
            terminal_info = mt5.terminal_info()
            account_info = mt5.account_info()
            
            return {
                'connected': terminal_info is not None,
                'terminal_name': terminal_info.name if terminal_info else None,
                'account_number': account_info.login if account_info else None,
                'server': account_info.server if account_info else None,
                'balance': float(account_info.balance) if account_info else 0,
                'equity': float(account_info.equity) if account_info else 0,
                'margin_level': float(account_info.margin_level) if account_info else 0
            }
        except Exception as e:
            return {
                'connected': False,
                'error': str(e)
            }
```

### 取引監視機能
```python
# backend/monitoring/trading_monitor.py
class TradingMonitor:
    def __init__(self, db_session, websocket_manager: WebSocketManager):
        self.db = db_session
        self.websocket_manager = websocket_manager
        self.monitoring_active = False
        
    async def start_monitoring(self):
        """取引監視開始"""
        self.monitoring_active = True
        
        # バックグラウンドタスクとして実行
        asyncio.create_task(self._trading_status_monitor())
        asyncio.create_task(self._position_monitor())
        asyncio.create_task(self._risk_monitor())
    
    async def _trading_status_monitor(self):
        """取引状況監視"""
        while self.monitoring_active:
            try:
                # 今日の取引統計
                today_stats = await self._get_today_trading_stats()
                
                # リアルタイム損益
                current_pnl = await self._get_current_pnl()
                
                # 取引統計送信
                await self.websocket_manager.broadcast({
                    'type': 'trading_stats',
                    'timestamp': datetime.now().isoformat(),
                    'data': {
                        'today_stats': today_stats,
                        'current_pnl': current_pnl
                    }
                })
                
                await asyncio.sleep(5)  # 5秒間隔
                
            except Exception as e:
                logger.error(f"Trading monitoring error: {e}")
                await asyncio.sleep(30)
    
    async def _get_today_trading_stats(self) -> dict:
        """本日の取引統計"""
        today = datetime.now().date()
        
        trades = self.db.query(Trade).filter(
            Trade.entry_time >= today,
            Trade.profit_loss.isnot(None)
        ).all()
        
        if not trades:
            return {
                'total_trades': 0,
                'winning_trades': 0,
                'losing_trades': 0,
                'win_rate': 0,
                'total_pnl': 0,
                'largest_win': 0,
                'largest_loss': 0
            }
        
        winning_trades = [t for t in trades if t.profit_loss > 0]
        losing_trades = [t for t in trades if t.profit_loss < 0]
        
        return {
            'total_trades': len(trades),
            'winning_trades': len(winning_trades),
            'losing_trades': len(losing_trades),
            'win_rate': len(winning_trades) / len(trades) * 100,
            'total_pnl': sum([t.profit_loss for t in trades]),
            'largest_win': max([t.profit_loss for t in winning_trades]) if winning_trades else 0,
            'largest_loss': min([t.profit_loss for t in losing_trades]) if losing_trades else 0
        }
    
    async def _position_monitor(self):
        """ポジション監視"""
        while self.monitoring_active:
            try:
                # 現在のポジション取得
                positions = await self._get_current_positions()
                
                # ポジション状況送信
                await self.websocket_manager.broadcast({
                    'type': 'positions_update',
                    'timestamp': datetime.now().isoformat(),
                    'data': positions
                })
                
                # 大きな損失のアラート
                for position in positions:
                    if position.get('profit', 0) < -10000:  # 1万円以上の損失
                        await self.websocket_manager.broadcast({
                            'type': 'trading_alerts',
                            'timestamp': datetime.now().isoformat(),
                            'alerts': [{
                                'level': 'warning',
                                'type': 'large_loss',
                                'message': f"大きな含み損: {position['profit']:,.0f}円 ({position['symbol']})",
                                'position_id': position['id']
                            }]
                        })
                
                await asyncio.sleep(2)  # 2秒間隔
                
            except Exception as e:
                logger.error(f"Position monitoring error: {e}")
                await asyncio.sleep(10)
```

### ログビューア機能
```python
# backend/monitoring/log_viewer.py
class LogViewer:
    def __init__(self, websocket_manager: WebSocketManager):
        self.websocket_manager = websocket_manager
        self.log_files = {
            'trading': 'logs/trading.log',
            'system': 'logs/system.log',
            'error': 'logs/error.log'
        }
    
    async def stream_logs(self, log_type: str = 'trading', lines: int = 100):
        """ログストリーミング"""
        if log_type not in self.log_files:
            return
        
        log_file = self.log_files[log_type]
        
        try:
            # 最新のログ行を取得
            with open(log_file, 'r', encoding='utf-8') as f:
                # ファイル末尾から指定行数を読み取り
                lines_list = f.readlines()
                recent_lines = lines_list[-lines:] if len(lines_list) > lines else lines_list
            
            # WebSocketで送信
            await self.websocket_manager.broadcast({
                'type': 'log_data',
                'log_type': log_type,
                'timestamp': datetime.now().isoformat(),
                'data': {
                    'lines': [line.strip() for line in recent_lines],
                    'total_lines': len(lines_list)
                }
            })
            
        except FileNotFoundError:
            await self.websocket_manager.broadcast({
                'type': 'log_error',
                'message': f"ログファイルが見つかりません: {log_file}"
            })
        except Exception as e:
            logger.error(f"Log streaming error: {e}")
    
    async def watch_logs(self, log_type: str = 'trading'):
        """ログファイル変更監視"""
        log_file = self.log_files.get(log_type)
        if not log_file:
            return
        
        try:
            # ファイル監視（簡易実装）
            last_modified = os.path.getmtime(log_file)
            
            while True:
                current_modified = os.path.getmtime(log_file)
                
                if current_modified > last_modified:
                    # ファイルが更新された
                    await self.stream_logs(log_type, 10)  # 最新10行を送信
                    last_modified = current_modified
                
                await asyncio.sleep(1)  # 1秒間隔でチェック
                
        except Exception as e:
            logger.error(f"Log watching error: {e}")
```

### フロントエンド WebSocket クライアント
```typescript
// hooks/useWebSocket.ts
import { useEffect, useRef, useState } from 'react'

interface WebSocketData {
  type: string
  timestamp: string
  data?: any
  alerts?: any[]
}

export function useWebSocket(url: string) {
  const [isConnected, setIsConnected] = useState(false)
  const [lastMessage, setLastMessage] = useState<WebSocketData | null>(null)
  const [systemStats, setSystemStats] = useState<any>(null)
  const [tradingStats, setTradingStats] = useState<any>(null)
  const [alerts, setAlerts] = useState<any[]>([])
  const [logs, setLogs] = useState<string[]>([])
  
  const ws = useRef<WebSocket | null>(null)

  useEffect(() => {
    const connectWebSocket = () => {
      try {
        ws.current = new WebSocket(url)

        ws.current.onopen = () => {
          setIsConnected(true)
          console.log('WebSocket connected')
        }

        ws.current.onmessage = (event) => {
          const data: WebSocketData = JSON.parse(event.data)
          setLastMessage(data)

          // メッセージタイプ別処理
          switch (data.type) {
            case 'system_stats':
              setSystemStats(data.data)
              break
            case 'trading_stats':
              setTradingStats(data.data)
              break
            case 'system_alerts':
            case 'trading_alerts':
              setAlerts(prev => [...data.alerts, ...prev].slice(0, 50))
              break
            case 'log_data':
              setLogs(data.data.lines)
              break
          }
        }

        ws.current.onclose = () => {
          setIsConnected(false)
          console.log('WebSocket disconnected')
          
          // 3秒後に再接続試行
          setTimeout(connectWebSocket, 3000)
        }

        ws.current.onerror = (error) => {
          console.error('WebSocket error:', error)
        }

      } catch (error) {
        console.error('WebSocket connection failed:', error)
        setTimeout(connectWebSocket, 3000)
      }
    }

    connectWebSocket()

    return () => {
      if (ws.current) {
        ws.current.close()
      }
    }
  }, [url])

  const sendMessage = (message: any) => {
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify(message))
    }
  }

  return {
    isConnected,
    lastMessage,
    systemStats,
    tradingStats,
    alerts,
    logs,
    sendMessage
  }
}

// components/monitoring/SystemStatsCard.tsx
export function SystemStatsCard() {
  const { systemStats } = useWebSocket('ws://localhost:8000/ws/monitoring')

  if (!systemStats) return <div>データ読み込み中...</div>

  return (
    <Card>
      <CardHeader title="システム状況" />
      <CardContent>
        <Grid container spacing={2}>
          <Grid item xs={12} sm={6} md={3}>
            <Paper sx={{ p: 2, textAlign: 'center' }}>
              <Typography variant="h6">CPU</Typography>
              <Typography 
                variant="h4" 
                color={systemStats.cpu_percent > 80 ? 'error' : 'primary'}
              >
                {systemStats.cpu_percent}%
              </Typography>
            </Paper>
          </Grid>
          
          <Grid item xs={12} sm={6} md={3}>
            <Paper sx={{ p: 2, textAlign: 'center' }}>
              <Typography variant="h6">メモリ</Typography>
              <Typography 
                variant="h4"
                color={systemStats.memory_percent > 85 ? 'error' : 'primary'}
              >
                {systemStats.memory_percent}%
              </Typography>
            </Paper>
          </Grid>
          
          <Grid item xs={12} sm={6} md={3}>
            <Paper sx={{ p: 2, textAlign: 'center' }}>
              <Typography variant="h6">ディスク</Typography>
              <Typography 
                variant="h4"
                color={systemStats.disk_percent > 90 ? 'error' : 'primary'}
              >
                {systemStats.disk_percent}%
              </Typography>
            </Paper>
          </Grid>
          
          <Grid item xs={12} sm={6} md={3}>
            <Paper sx={{ p: 2, textAlign: 'center' }}>
              <Typography variant="h6">空きメモリ</Typography>
              <Typography variant="h4">
                {systemStats.memory_available_gb}GB
              </Typography>
            </Paper>
          </Grid>
        </Grid>
      </CardContent>
    </Card>
  )
}
```

### API エンドポイント
```python
# WebSocketエンドポイント
@app.websocket("/ws/monitoring")
async def websocket_endpoint(websocket: WebSocket):
    """監視用WebSocket"""
    await websocket_manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            
            # クライアントからのリクエスト処理
            if message.get('type') == 'request_logs':
                await log_viewer.stream_logs(
                    message.get('log_type', 'trading'),
                    message.get('lines', 100)
                )
                
    except WebSocketDisconnect:
        websocket_manager.disconnect(websocket)

# REST API
@app.get("/api/v1/monitoring/system-status")
async def get_system_status():
    """システム状況取得"""
    
@app.get("/api/v1/monitoring/alerts")
async def get_recent_alerts(limit: int = 50):
    """最新アラート取得"""
    
@app.get("/api/v1/monitoring/logs/{log_type}")
async def get_logs(log_type: str, lines: int = 100):
    """ログ取得"""
```

## アラート通知レベル
- **INFO**: 情報通知
- **WARNING**: 警告（要注意）
- **ERROR**: エラー（即座に対応が必要）
- **CRITICAL**: 緊急事態（システム停止等）

## 見積もり
**3日**

## 依存関係
- チケット005: 自動売買エンジン
- チケット009: Next.jsフロントエンド

## 完了条件
- [ ] WebSocketサーバーが動作する
- [ ] システム監視が動作する
- [ ] リアルタイムダッシュボードが更新される
- [ ] アラート通知が動作する
- [ ] ログビューアが動作する