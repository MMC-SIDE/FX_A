# チケット006: リスク管理機能

## 概要
取引のリスクを管理し、損失を制限するための包括的なリスク管理システムを実装する。

## 目的
- 1取引あたりのリスク制限
- 最大ドローダウン監視
- ポジションサイジング計算
- 緊急停止機能

## 要件
- 設定可能なリスクパラメータ
- リアルタイムリスク監視
- 自動ポジションサイジング
- ストップロス・テイクプロフィット計算
- 緊急停止トリガー

## 受け入れ基準
- [×] リスク管理クラスの実装
- [×] ポジションサイジング計算機能
- [×] ストップロス・テイクプロフィット計算
- [×] ドローダウン監視機能
- [×] 緊急停止機能
- [×] リスク設定API

## 技術仕様

### リスク管理クラス
```python
# backend/core/risk_manager.py
class RiskManager:
    def __init__(self, db_session):
        self.db = db_session
        self.settings = self._load_settings()
        self.account_info = None
        
    def _load_settings(self) -> dict:
        """リスク設定の読み込み"""
        settings = {}
        risk_settings = self.db.query(SystemSettings).filter(
            SystemSettings.category == 'risk_management'
        ).all()
        
        for setting in risk_settings:
            settings[setting.key] = json.loads(setting.value)
        
        # デフォルト値
        default_settings = {
            'max_risk_per_trade': 20.0,  # %
            'max_drawdown': 20.0,        # %
            'use_nanpin': True,
            'nanpin_max_count': 3,
            'nanpin_interval_pips': 10,
            'stop_loss_pips': 50,
            'take_profit_pips': 100,
            'max_positions': 1,
            'risk_reward_ratio': 2.0,
            'consecutive_loss_limit': 5,
            'daily_loss_limit': 5.0,     # %
            'margin_level_limit': 200.0   # %
        }
        
        for key, value in default_settings.items():
            if key not in settings:
                settings[key] = value
                
        return settings
    
    def update_settings(self, new_settings: dict):
        """リスク設定の更新"""
        for key, value in new_settings.items():
            if key in self.settings:
                self.settings[key] = value
                
                # DB更新
                setting = self.db.query(SystemSettings).filter(
                    SystemSettings.category == 'risk_management',
                    SystemSettings.key == key
                ).first()
                
                if setting:
                    setting.value = json.dumps(value)
                else:
                    new_setting = SystemSettings(
                        category='risk_management',
                        key=key,
                        value=json.dumps(value)
                    )
                    self.db.add(new_setting)
        
        self.db.commit()
    
    def update_account_info(self, mt5_client):
        """アカウント情報の更新"""
        account_info = mt5_client.get_account_info()
        self.account_info = {
            'balance': account_info.balance,
            'equity': account_info.equity,
            'margin': account_info.margin,
            'free_margin': account_info.margin_free,
            'margin_level': account_info.margin_level,
            'profit': account_info.profit
        }
    
    def calculate_lot_size(self, symbol: str, order_type: str) -> float:
        """ロットサイズ計算"""
        if not self.account_info:
            raise ValueError("Account info not available")
        
        # リスク金額計算
        risk_amount = (
            self.account_info['balance'] * 
            self.settings['max_risk_per_trade'] / 100
        )
        
        # ストップロス距離
        sl_pips = self.settings['stop_loss_pips']
        
        # 1pipの価値計算（USDJPY想定）
        pip_value = 1000  # 0.1ロットでUSDJPYの1pip = 1000円
        
        # ロットサイズ計算
        lot_size = risk_amount / (sl_pips * pip_value)
        
        # 最小・最大ロット制限
        lot_size = max(0.01, min(lot_size, 10.0))
        
        # 0.01刻みに丸める
        lot_size = round(lot_size, 2)
        
        logger.info(f"Calculated lot size: {lot_size} (risk: {risk_amount:.0f}円)")
        
        return lot_size
    
    def calculate_sl_tp(self, symbol: str, order_type: str, 
                       entry_price: float) -> tuple:
        """ストップロス・テイクプロフィット計算"""
        sl_pips = self.settings['stop_loss_pips']
        rr_ratio = self.settings['risk_reward_ratio']
        tp_pips = sl_pips * rr_ratio
        
        # pip値（USDJPY想定：0.01）
        pip_size = 0.01
        
        if order_type == 'BUY':
            sl = entry_price - (sl_pips * pip_size)
            tp = entry_price + (tp_pips * pip_size)
        else:  # SELL
            sl = entry_price + (sl_pips * pip_size)
            tp = entry_price - (tp_pips * pip_size)
        
        return round(sl, 3), round(tp, 3)
    
    def check_risk_limits(self) -> bool:
        """リスク制限チェック"""
        if not self.account_info:
            return False
        
        # 証拠金維持率チェック
        if self.account_info['margin_level'] < self.settings['margin_level_limit']:
            logger.warning(f"Margin level too low: {self.account_info['margin_level']:.1f}%")
            return False
        
        # 日次損失制限チェック
        daily_loss_limit = self.account_info['balance'] * self.settings['daily_loss_limit'] / 100
        if self._get_daily_loss() > daily_loss_limit:
            logger.warning(f"Daily loss limit exceeded")
            return False
        
        # 連続損失チェック
        if self._get_consecutive_losses() >= self.settings['consecutive_loss_limit']:
            logger.warning(f"Consecutive loss limit exceeded")
            return False
        
        # 最大ポジション数チェック
        if self._get_position_count() >= self.settings['max_positions']:
            logger.warning(f"Maximum position count reached")
            return False
        
        return True
    
    def should_emergency_stop(self) -> bool:
        """緊急停止判定"""
        if not self.account_info:
            return True
        
        # 最大ドローダウンチェック
        initial_balance = self._get_initial_balance()
        current_equity = self.account_info['equity']
        
        drawdown_percent = (initial_balance - current_equity) / initial_balance * 100
        
        if drawdown_percent > self.settings['max_drawdown']:
            logger.error(f"Maximum drawdown exceeded: {drawdown_percent:.2f}%")
            return True
        
        # 証拠金維持率の緊急レベル
        if self.account_info['margin_level'] < 150:
            logger.error(f"Critical margin level: {self.account_info['margin_level']:.1f}%")
            return True
        
        return False
    
    def _get_daily_loss(self) -> float:
        """本日の損失額取得"""
        today = datetime.now().date()
        
        trades = self.db.query(Trade).filter(
            Trade.entry_time >= today,
            Trade.profit_loss.isnot(None)
        ).all()
        
        total_loss = sum([
            trade.profit_loss for trade in trades 
            if trade.profit_loss < 0
        ])
        
        return abs(total_loss)
    
    def _get_consecutive_losses(self) -> int:
        """連続損失回数取得"""
        recent_trades = self.db.query(Trade).filter(
            Trade.profit_loss.isnot(None)
        ).order_by(Trade.exit_time.desc()).limit(20).all()
        
        consecutive_losses = 0
        for trade in recent_trades:
            if trade.profit_loss < 0:
                consecutive_losses += 1
            else:
                break
        
        return consecutive_losses
    
    def _get_position_count(self) -> int:
        """現在のポジション数取得"""
        open_trades = self.db.query(Trade).filter(
            Trade.exit_time.is_(None)
        ).count()
        
        return open_trades
    
    def _get_initial_balance(self) -> float:
        """初期残高取得"""
        # システム設定または最初の取引記録から取得
        setting = self.db.query(SystemSettings).filter(
            SystemSettings.category == 'account',
            SystemSettings.key == 'initial_balance'
        ).first()
        
        if setting:
            return float(json.loads(setting.value))
        
        # デフォルトで現在の残高を使用（初回起動時）
        return self.account_info['balance']
```

### ドローダウン監視
```python
class DrawdownMonitor:
    def __init__(self, risk_manager: RiskManager):
        self.risk_manager = risk_manager
        self.peak_equity = 0
        self.current_drawdown = 0
        
    def update(self, current_equity: float):
        """ドローダウン更新"""
        # 新しい最高値
        if current_equity > self.peak_equity:
            self.peak_equity = current_equity
            self.current_drawdown = 0
        else:
            # ドローダウン計算
            self.current_drawdown = (
                (self.peak_equity - current_equity) / self.peak_equity * 100
            )
        
        # アラート条件チェック
        warning_level = self.risk_manager.settings['max_drawdown'] * 0.8
        if self.current_drawdown > warning_level:
            logger.warning(f"Drawdown warning: {self.current_drawdown:.2f}%")
        
        return self.current_drawdown
    
    def get_max_drawdown_history(self, days: int = 30) -> dict:
        """過去のドローダウン履歴"""
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        # 日次残高データを取得（実装は要検討）
        # データベースから過去の残高データを取得
        
        return {
            'max_drawdown': 0,  # 最大ドローダウン
            'duration': 0,      # ドローダウン期間
            'recovery_days': 0  # 回復日数
        }
```

### リスク設定API
```python
# FastAPI エンドポイント
@app.get("/api/v1/risk/settings")
async def get_risk_settings():
    """リスク設定取得"""
    return risk_manager.settings

@app.put("/api/v1/risk/settings")
async def update_risk_settings(settings: RiskSettingsModel):
    """リスク設定更新"""
    risk_manager.update_settings(settings.dict())
    return {"status": "updated"}

@app.get("/api/v1/risk/status")
async def get_risk_status():
    """リスク状況取得"""
    return {
        "account_info": risk_manager.account_info,
        "current_drawdown": drawdown_monitor.current_drawdown,
        "daily_loss": risk_manager._get_daily_loss(),
        "consecutive_losses": risk_manager._get_consecutive_losses(),
        "position_count": risk_manager._get_position_count()
    }
```

### リスク設定モデル
```python
# backend/models/risk_models.py
from pydantic import BaseModel, Field

class RiskSettingsModel(BaseModel):
    max_risk_per_trade: float = Field(ge=0.1, le=100, description="1取引あたりの最大リスク(%)")
    max_drawdown: float = Field(ge=1, le=100, description="最大ドローダウン(%)")
    use_nanpin: bool = Field(description="ナンピン機能の使用")
    nanpin_max_count: int = Field(ge=1, le=10, description="ナンピン最大回数")
    stop_loss_pips: int = Field(ge=5, le=500, description="ストップロス(pips)")
    take_profit_pips: int = Field(ge=5, le=1000, description="テイクプロフィット(pips)")
    risk_reward_ratio: float = Field(ge=0.5, le=10, description="リスクリワード比率")
```

## アラート機能
- ドローダウン警告レベル到達
- 証拠金維持率低下
- 連続損失発生
- 日次損失限界接近

## 見積もり
**3日**

## 依存関係
- チケット003: データベース設計実装

## 完了条件
- [×] リスク設定が正常に動作する
- [×] ポジションサイジングが適切に計算される
- [×] ドローダウン監視が動作する
- [×] 緊急停止機能が動作する
- [×] リスク設定APIが動作する