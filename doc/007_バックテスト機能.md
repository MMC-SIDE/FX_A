# チケット007: バックテスト機能

## 概要
過去データを使用してトレーディング戦略のパフォーマンスを検証するバックテストエンジンを実装する。

## 目的
- 全通貨ペア・全時間軸での自動検証
- 最適パラメータの発見
- 戦略のパフォーマンス評価
- 統計的な分析結果の提供

## 要件
- 過去1年分のデータでテスト実行
- 複数パラメータの組み合わせテスト
- 詳細な統計結果の生成
- 結果の可視化データ作成

## 受け入れ基準
- [×] バックテストエンジンの実装
- [×] パラメータ最適化機能
- [×] パフォーマンス評価指標の計算
- [×] 結果の保存・取得API
- [×] エクイティカーブ生成
- [×] 統計レポート生成

## 技術仕様

### バックテストエンジン
```python
# backend/backtest/backtest_engine.py
class BacktestEngine:
    def __init__(self, db_session):
        self.db = db_session
        self.results = {}
        
    async def run_backtest(self, 
                         symbol: str,
                         timeframe: str,
                         start_date: datetime,
                         end_date: datetime,
                         parameters: dict,
                         initial_balance: float = 100000) -> dict:
        """バックテスト実行"""
        
        # テストID生成
        test_id = str(uuid.uuid4())
        
        # データ取得
        historical_data = await self._get_historical_data(
            symbol, timeframe, start_date, end_date
        )
        
        if historical_data.empty:
            raise ValueError(f"No data available for {symbol} {timeframe}")
        
        # 特徴量作成
        feature_engine = FeatureEngineering()
        features_data = feature_engine.create_features(historical_data)
        
        # モデル学習（分割データで）
        model = await self._train_model_for_backtest(
            features_data, parameters
        )
        
        # バックテスト実行
        trades, equity_curve = await self._simulate_trading(
            features_data, model, parameters, initial_balance
        )
        
        # 統計計算
        statistics = self._calculate_statistics(
            trades, equity_curve, initial_balance
        )
        
        # 結果保存
        await self._save_backtest_result(
            test_id, symbol, timeframe, 
            start_date, end_date,
            initial_balance, statistics,
            parameters, equity_curve
        )
        
        return {
            'test_id': test_id,
            'statistics': statistics,
            'equity_curve': equity_curve,
            'trades': trades
        }
    
    async def _simulate_trading(self, 
                              data: pd.DataFrame,
                              model: LightGBMPredictor,
                              parameters: dict,
                              initial_balance: float) -> tuple:
        """取引シミュレーション"""
        
        balance = initial_balance
        equity = initial_balance
        position = None
        trades = []
        equity_curve = []
        
        # リスク管理設定
        risk_per_trade = parameters.get('risk_per_trade', 2.0) / 100
        risk_reward_ratio = parameters.get('risk_reward_ratio', 2.0)
        use_nanpin = parameters.get('use_nanpin', False)
        nanpin_max_count = parameters.get('nanpin_max_count', 3)
        
        for i in range(len(data)):
            current_row = data.iloc[i]
            current_time = current_row.name
            current_price = current_row['close']
            
            # 予測実行（十分なデータがある場合のみ）
            if i < 100:  # 最初の100行はスキップ
                equity_curve.append({
                    'timestamp': current_time,
                    'equity': equity,
                    'balance': balance
                })
                continue
            
            # 特徴量抽出（現在の行まで）
            features = data.iloc[i-50:i+1]  # 50行分の履歴
            
            try:
                predictions, confidence = model.predict(features.tail(1))
                signal = ['HOLD', 'BUY', 'SELL'][predictions[0]]
                conf_score = confidence[0]
            except:
                signal = 'HOLD'
                conf_score = 0.0
            
            # 最小信頼度チェック
            min_confidence = parameters.get('min_confidence', 0.7)
            if conf_score < min_confidence:
                signal = 'HOLD'
            
            # ポジション管理
            if position is None:  # ポジションなし
                if signal in ['BUY', 'SELL']:
                    position = await self._open_backtest_position(
                        signal, current_price, current_time,
                        balance, risk_per_trade, risk_reward_ratio
                    )
            else:  # ポジションあり
                # エグジット条件チェック
                exit_info = await self._check_exit_conditions(
                    position, current_price, current_time, signal
                )
                
                if exit_info['should_exit']:
                    # ポジション決済
                    trade_result = await self._close_backtest_position(
                        position, exit_info['exit_price'], 
                        current_time, exit_info['reason']
                    )
                    
                    trades.append(trade_result)
                    balance += trade_result['profit_loss']
                    equity = balance
                    position = None
                
                # ナンピンチェック
                elif use_nanpin and position['nanpin_count'] < nanpin_max_count:
                    nanpin_result = await self._check_nanpin_conditions(
                        position, current_price, parameters
                    )
                    if nanpin_result:
                        position = await self._execute_backtest_nanpin(
                            position, current_price, current_time
                        )
            
            # エクイティ更新
            if position:
                unrealized_pnl = self._calculate_unrealized_pnl(
                    position, current_price
                )
                equity = balance + unrealized_pnl
            else:
                equity = balance
            
            equity_curve.append({
                'timestamp': current_time,
                'equity': equity,
                'balance': balance,
                'unrealized_pnl': unrealized_pnl if position else 0
            })
        
        # 最終ポジションがあれば決済
        if position:
            final_trade = await self._close_backtest_position(
                position, current_price, current_time, 'END_OF_TEST'
            )
            trades.append(final_trade)
            balance += final_trade['profit_loss']
        
        return trades, equity_curve
    
    def _calculate_statistics(self, 
                            trades: list, 
                            equity_curve: list,
                            initial_balance: float) -> dict:
        """統計指標計算"""
        
        if not trades:
            return self._empty_statistics()
        
        # 基本統計
        total_trades = len(trades)
        winning_trades = len([t for t in trades if t['profit_loss'] > 0])
        losing_trades = len([t for t in trades if t['profit_loss'] < 0])
        
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        
        # 損益計算
        profits = [t['profit_loss'] for t in trades if t['profit_loss'] > 0]
        losses = [t['profit_loss'] for t in trades if t['profit_loss'] < 0]
        
        total_profit = sum(profits) if profits else 0
        total_loss = abs(sum(losses)) if losses else 0
        net_profit = total_profit - total_loss
        
        # プロフィットファクター
        profit_factor = total_profit / total_loss if total_loss > 0 else float('inf')
        
        # 平均損益
        avg_win = np.mean(profits) if profits else 0
        avg_loss = abs(np.mean(losses)) if losses else 0
        
        # 最大値
        largest_win = max(profits) if profits else 0
        largest_loss = abs(min(losses)) if losses else 0
        
        # エクイティカーブ分析
        equity_values = [point['equity'] for point in equity_curve]
        
        # 最大ドローダウン
        peak = equity_values[0]
        max_drawdown = 0
        max_drawdown_percent = 0
        
        for equity in equity_values:
            if equity > peak:
                peak = equity
            drawdown = peak - equity
            drawdown_percent = drawdown / peak * 100
            
            if drawdown > max_drawdown:
                max_drawdown = drawdown
                max_drawdown_percent = drawdown_percent
        
        # シャープレシオ
        returns = self._calculate_returns(equity_values)
        sharpe_ratio = self._calculate_sharpe_ratio(returns)
        
        # ソルティノレシオ
        sortino_ratio = self._calculate_sortino_ratio(returns)
        
        # カルマーレシオ
        annual_return = (equity_values[-1] / initial_balance - 1) * 100
        calmar_ratio = annual_return / max_drawdown_percent if max_drawdown_percent > 0 else 0
        
        return {
            'total_trades': total_trades,
            'winning_trades': winning_trades,
            'losing_trades': losing_trades,
            'win_rate': round(win_rate * 100, 2),
            'total_profit': round(total_profit, 2),
            'total_loss': round(total_loss, 2),
            'net_profit': round(net_profit, 2),
            'profit_factor': round(profit_factor, 4),
            'avg_win': round(avg_win, 2),
            'avg_loss': round(avg_loss, 2),
            'largest_win': round(largest_win, 2),
            'largest_loss': round(largest_loss, 2),
            'max_drawdown': round(max_drawdown, 2),
            'max_drawdown_percent': round(max_drawdown_percent, 2),
            'sharpe_ratio': round(sharpe_ratio, 4),
            'sortino_ratio': round(sortino_ratio, 4),
            'calmar_ratio': round(calmar_ratio, 4),
            'final_balance': round(equity_values[-1], 2),
            'return_percent': round((equity_values[-1] / initial_balance - 1) * 100, 2)
        }
```

### パラメータ最適化
```python
class ParameterOptimizer:
    def __init__(self, backtest_engine: BacktestEngine):
        self.backtest_engine = backtest_engine
        
    async def optimize_parameters(self,
                                symbol: str,
                                timeframe: str,
                                start_date: datetime,
                                end_date: datetime,
                                parameter_ranges: dict,
                                optimization_metric: str = 'sharpe_ratio',
                                max_iterations: int = 100) -> dict:
        """パラメータ最適化実行"""
        
        best_result = None
        best_score = float('-inf')
        all_results = []
        
        # パラメータの組み合わせ生成
        param_combinations = self._generate_parameter_combinations(
            parameter_ranges, max_iterations
        )
        
        for i, params in enumerate(param_combinations):
            try:
                # バックテスト実行
                result = await self.backtest_engine.run_backtest(
                    symbol, timeframe, start_date, end_date, params
                )
                
                # 評価指標取得
                score = result['statistics'].get(optimization_metric, 0)
                
                result_data = {
                    'parameters': params,
                    'score': score,
                    'statistics': result['statistics']
                }
                all_results.append(result_data)
                
                # 最良結果更新
                if score > best_score:
                    best_score = score
                    best_result = result_data
                
                logger.info(f"Optimization {i+1}/{len(param_combinations)}: "
                          f"{optimization_metric}={score:.4f}")
                
            except Exception as e:
                logger.error(f"Optimization iteration {i+1} failed: {e}")
                continue
        
        return {
            'best_parameters': best_result['parameters'] if best_result else None,
            'best_score': best_score,
            'all_results': all_results,
            'optimization_metric': optimization_metric
        }
    
    def _generate_parameter_combinations(self, 
                                       parameter_ranges: dict,
                                       max_iterations: int) -> list:
        """パラメータ組み合わせ生成"""
        combinations = []
        
        # ベイズ最適化またはグリッドサーチ
        if max_iterations <= 50:
            # グリッドサーチ
            combinations = self._grid_search_combinations(parameter_ranges)
        else:
            # ランダムサーチ
            combinations = self._random_search_combinations(
                parameter_ranges, max_iterations
            )
        
        return combinations[:max_iterations]
```

### 全通貨ペア・全時間軸テスト
```python
class ComprehensiveBacktest:
    def __init__(self, backtest_engine: BacktestEngine):
        self.backtest_engine = backtest_engine
        
    async def run_comprehensive_test(self,
                                   symbols: list = None,
                                   timeframes: list = None,
                                   test_period_months: int = 12) -> dict:
        """全通貨ペア・全時間軸での包括的テスト"""
        
        if symbols is None:
            symbols = ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY', 
                      'NZDJPY', 'CADJPY', 'CHFJPY']
        
        if timeframes is None:
            timeframes = ['M5', 'M15', 'M30', 'H1', 'H4']
        
        end_date = datetime.now()
        start_date = end_date - timedelta(days=test_period_months * 30)
        
        results = {}
        
        for symbol in symbols:
            results[symbol] = {}
            for timeframe in timeframes:
                try:
                    logger.info(f"Testing {symbol} {timeframe}...")
                    
                    # 最適パラメータでバックテスト実行
                    optimal_params = await self._get_optimal_parameters(
                        symbol, timeframe
                    )
                    
                    result = await self.backtest_engine.run_backtest(
                        symbol, timeframe, start_date, end_date, optimal_params
                    )
                    
                    results[symbol][timeframe] = result['statistics']
                    
                except Exception as e:
                    logger.error(f"Test failed for {symbol} {timeframe}: {e}")
                    results[symbol][timeframe] = None
        
        # 総合分析
        summary = self._analyze_comprehensive_results(results)
        
        return {
            'individual_results': results,
            'summary': summary,
            'test_period': {
                'start_date': start_date.isoformat(),
                'end_date': end_date.isoformat()
            }
        }
```

### API エンドポイント
```python
@app.post("/api/v1/backtest/run")
async def run_backtest(request: BacktestRequest):
    """バックテスト実行"""
    
@app.get("/api/v1/backtest/results/{test_id}")
async def get_backtest_result(test_id: str):
    """バックテスト結果取得"""
    
@app.post("/api/v1/backtest/optimize")
async def optimize_parameters(request: OptimizationRequest):
    """パラメータ最適化実行"""
    
@app.post("/api/v1/backtest/comprehensive")
async def run_comprehensive_backtest():
    """包括的バックテスト実行"""
```

## パフォーマンス要件
- 1通貨ペア・1年分: 10分以内
- 全通貨ペア・全時間軸: 2時間以内
- 結果取得: 3秒以内

## 見積もり
**4日**

## 依存関係
- チケット003: データベース設計実装
- チケット004: LightGBM機械学習エンジン

## 完了条件
- [×] 単一通貨ペアのバックテストが動作する
- [×] パラメータ最適化が動作する
- [×] 全通貨ペア・全時間軸テストが完了する
- [×] 統計結果が正しく計算される
- [×] 結果の保存・取得APIが動作する