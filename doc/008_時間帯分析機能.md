# チケット008: 時間帯分析機能

## 概要
勝率の高い時間帯を特定するための分析機能を実装する。

## 目的
- 市場別（東京、ロンドン、ニューヨーク）パフォーマンス分析
- 曜日別・時間帯別の勝率分析
- 経済指標発表前後の影響分析
- 最適な取引時間帯の自動検出

## 要件
- 市場セッション別の分析
- 時間帯別の詳細分析
- 曜日別のパフォーマンス分析
- 経済指標カレンダーとの連携
- 分析結果の可視化データ生成

## 受け入れ基準
- [×] 時間帯分析エンジンの実装
- [×] 市場セッション分析機能
- [×] 曜日別分析機能
- [×] 経済指標連携機能
- [×] 分析結果API
- [×] 最適時間帯検出機能

## 技術仕様

### 時間帯分析エンジン
```python
# backend/analysis/timeframe_analyzer.py
class TimeframeAnalyzer:
    def __init__(self, db_session):
        self.db = db_session
        self.timezone_jst = pytz.timezone('Asia/Tokyo')
        
    def analyze_market_sessions(self, 
                              symbol: str,
                              period_days: int = 365) -> dict:
        """市場セッション別分析"""
        
        end_date = datetime.now()
        start_date = end_date - timedelta(days=period_days)
        
        # 取引データ取得
        trades = self.db.query(Trade).filter(
            Trade.symbol == symbol,
            Trade.entry_time >= start_date,
            Trade.profit_loss.isnot(None)
        ).all()
        
        if not trades:
            return self._empty_session_analysis()
        
        # 市場セッション定義（JST基準）
        sessions = {
            'tokyo': {'start': 9, 'end': 15},      # 9:00-15:00
            'london': {'start': 16, 'end': 24},    # 16:00-24:00  
            'ny': {'start': 21, 'end': 6},         # 21:00-6:00 (翌日)
            'overlap_london_ny': {'start': 21, 'end': 24}  # 21:00-24:00
        }
        
        session_stats = {}
        
        for session_name, time_range in sessions.items():
            session_trades = self._filter_trades_by_session(
                trades, time_range, session_name
            )
            
            if session_trades:
                stats = self._calculate_session_statistics(session_trades)
                session_stats[session_name] = stats
            else:
                session_stats[session_name] = self._empty_session_stats()
        
        # 最高パフォーマンスセッション特定
        best_session = self._find_best_session(session_stats)
        
        return {
            'symbol': symbol,
            'period_days': period_days,
            'session_statistics': session_stats,
            'best_session': best_session,
            'recommendations': self._generate_session_recommendations(session_stats)
        }
    
    def analyze_hourly_performance(self, 
                                 symbol: str,
                                 period_days: int = 365) -> dict:
        """時間別パフォーマンス分析"""
        
        end_date = datetime.now()
        start_date = end_date - timedelta(days=period_days)
        
        trades = self.db.query(Trade).filter(
            Trade.symbol == symbol,
            Trade.entry_time >= start_date,
            Trade.profit_loss.isnot(None)
        ).all()
        
        hourly_stats = {}
        
        for hour in range(24):
            hour_trades = [
                t for t in trades 
                if t.entry_time.astimezone(self.timezone_jst).hour == hour
            ]
            
            if hour_trades:
                stats = self._calculate_hourly_statistics(hour_trades, hour)
                hourly_stats[f"{hour:02d}:00"] = stats
            else:
                hourly_stats[f"{hour:02d}:00"] = self._empty_hourly_stats(hour)
        
        # 最高パフォーマンス時間帯特定
        best_hours = self._find_best_hours(hourly_stats)
        
        return {
            'symbol': symbol,
            'period_days': period_days,
            'hourly_statistics': hourly_stats,
            'best_hours': best_hours,
            'recommendations': self._generate_hourly_recommendations(hourly_stats)
        }
    
    def analyze_weekday_performance(self, 
                                  symbol: str,
                                  period_days: int = 365) -> dict:
        """曜日別パフォーマンス分析"""
        
        end_date = datetime.now()
        start_date = end_date - timedelta(days=period_days)
        
        trades = self.db.query(Trade).filter(
            Trade.symbol == symbol,
            Trade.entry_time >= start_date,
            Trade.profit_loss.isnot(None)
        ).all()
        
        weekday_names = ['月曜日', '火曜日', '水曜日', '木曜日', '金曜日', '土曜日', '日曜日']
        weekday_stats = {}
        
        for weekday in range(7):
            weekday_trades = [
                t for t in trades 
                if t.entry_time.astimezone(self.timezone_jst).weekday() == weekday
            ]
            
            if weekday_trades:
                stats = self._calculate_weekday_statistics(weekday_trades, weekday)
                weekday_stats[weekday_names[weekday]] = stats
            else:
                weekday_stats[weekday_names[weekday]] = self._empty_weekday_stats(weekday)
        
        # 最高パフォーマンス曜日特定
        best_weekdays = self._find_best_weekdays(weekday_stats)
        
        return {
            'symbol': symbol,
            'period_days': period_days,
            'weekday_statistics': weekday_stats,
            'best_weekdays': best_weekdays,
            'recommendations': self._generate_weekday_recommendations(weekday_stats)
        }
    
    def _calculate_session_statistics(self, trades: list) -> dict:
        """セッション統計計算"""
        total_trades = len(trades)
        winning_trades = len([t for t in trades if t.profit_loss > 0])
        losing_trades = len([t for t in trades if t.profit_loss < 0])
        
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        
        total_profit = sum([t.profit_loss for t in trades if t.profit_loss > 0])
        total_loss = abs(sum([t.profit_loss for t in trades if t.profit_loss < 0]))
        net_profit = sum([t.profit_loss for t in trades])
        
        profit_factor = total_profit / total_loss if total_loss > 0 else float('inf')
        avg_profit_per_trade = net_profit / total_trades if total_trades > 0 else 0
        
        return {
            'total_trades': total_trades,
            'winning_trades': winning_trades,
            'losing_trades': losing_trades,
            'win_rate': round(win_rate * 100, 2),
            'total_profit': round(total_profit, 2),
            'total_loss': round(total_loss, 2),
            'net_profit': round(net_profit, 2),
            'profit_factor': round(profit_factor, 4),
            'avg_profit_per_trade': round(avg_profit_per_trade, 2)
        }
    
    def _filter_trades_by_session(self, trades: list, 
                                time_range: dict, 
                                session_name: str) -> list:
        """セッション時間でトレードをフィルタ"""
        filtered_trades = []
        
        for trade in trades:
            trade_hour = trade.entry_time.astimezone(self.timezone_jst).hour
            
            if session_name == 'ny':
                # ニューヨーク時間は日をまたぐ
                if trade_hour >= 21 or trade_hour <= 6:
                    filtered_trades.append(trade)
            else:
                # 通常のセッション
                if time_range['start'] <= trade_hour < time_range['end']:
                    filtered_trades.append(trade)
        
        return filtered_trades
```

### 経済指標連携機能
```python
class EconomicNewsAnalyzer:
    def __init__(self, db_session):
        self.db = db_session
        
    async def fetch_economic_calendar(self, 
                                    start_date: datetime,
                                    end_date: datetime) -> list:
        """経済指標カレンダー取得"""
        # 外部APIから経済指標データを取得
        # (例: ForexFactory API、Investing.com API等)
        
        try:
            # サンプル実装（実際は外部API呼び出し）
            events = await self._fetch_from_external_api(start_date, end_date)
            
            # データベースに保存
            for event in events:
                existing = self.db.query(EconomicCalendar).filter(
                    EconomicCalendar.event_time == event['time'],
                    EconomicCalendar.event_name == event['name']
                ).first()
                
                if not existing:
                    calendar_entry = EconomicCalendar(
                        event_time=event['time'],
                        currency=event['currency'],
                        event_name=event['name'],
                        impact=event['impact'],
                        actual_value=event.get('actual'),
                        forecast_value=event.get('forecast'),
                        previous_value=event.get('previous')
                    )
                    self.db.add(calendar_entry)
            
            self.db.commit()
            return events
            
        except Exception as e:
            logger.error(f"Failed to fetch economic calendar: {e}")
            return []
    
    def analyze_news_impact(self, 
                          symbol: str,
                          impact_levels: list = ['high'],
                          time_window_minutes: int = 60) -> dict:
        """経済指標の影響分析"""
        
        # 高インパクトの経済指標取得
        high_impact_events = self.db.query(EconomicCalendar).filter(
            EconomicCalendar.impact.in_(impact_levels),
            EconomicCalendar.currency.in_(['USD', 'JPY', 'EUR'])  # 主要通貨
        ).all()
        
        analysis_results = []
        
        for event in high_impact_events:
            # 指標発表前後の価格変動分析
            event_time = event.event_time
            before_time = event_time - timedelta(minutes=time_window_minutes)
            after_time = event_time + timedelta(minutes=time_window_minutes)
            
            # 価格データ取得
            price_data = self.db.query(PriceData).filter(
                PriceData.symbol == symbol,
                PriceData.time.between(before_time, after_time),
                PriceData.timeframe == 'M1'
            ).order_by(PriceData.time).all()
            
            if len(price_data) >= 120:  # 最低2時間分のデータ
                volatility_analysis = self._analyze_event_volatility(
                    price_data, event_time
                )
                
                analysis_results.append({
                    'event': {
                        'name': event.event_name,
                        'time': event.event_time.isoformat(),
                        'currency': event.currency,
                        'impact': event.impact
                    },
                    'volatility_analysis': volatility_analysis
                })
        
        return {
            'symbol': symbol,
            'analyzed_events': len(analysis_results),
            'results': analysis_results,
            'summary': self._summarize_news_impact(analysis_results)
        }
    
    def _analyze_event_volatility(self, 
                                price_data: list, 
                                event_time: datetime) -> dict:
        """イベント前後のボラティリティ分析"""
        
        # データをDataFrameに変換
        df = pd.DataFrame([{
            'time': p.time,
            'close': float(p.close),
            'high': float(p.high),
            'low': float(p.low)
        } for p in price_data])
        
        # イベント時刻のインデックス取得
        event_idx = df[df['time'] <= event_time].index[-1]
        
        # 前後30分のデータ
        before_data = df.iloc[max(0, event_idx-30):event_idx]
        after_data = df.iloc[event_idx:min(len(df), event_idx+30)]
        
        # ボラティリティ計算
        before_volatility = before_data['close'].std()
        after_volatility = after_data['close'].std()
        
        # 価格変動幅
        price_before = before_data['close'].iloc[-1] if len(before_data) > 0 else 0
        price_after = after_data['close'].iloc[-1] if len(after_data) > 0 else 0
        price_change = abs(price_after - price_before) if price_before > 0 else 0
        price_change_percent = (price_change / price_before * 100) if price_before > 0 else 0
        
        return {
            'before_volatility': round(before_volatility, 5),
            'after_volatility': round(after_volatility, 5),
            'volatility_increase': round((after_volatility / before_volatility - 1) * 100, 2) if before_volatility > 0 else 0,
            'price_change': round(price_change, 5),
            'price_change_percent': round(price_change_percent, 4)
        }
```

### 最適時間帯検出
```python
class OptimalTimeFinder:
    def __init__(self, timeframe_analyzer: TimeframeAnalyzer):
        self.analyzer = timeframe_analyzer
        
    def find_optimal_trading_hours(self, 
                                 symbol: str,
                                 min_trades: int = 20,
                                 min_win_rate: float = 60.0,
                                 min_profit_factor: float = 1.2) -> dict:
        """最適な取引時間帯の検出"""
        
        # 時間別分析実行
        hourly_analysis = self.analyzer.analyze_hourly_performance(symbol)
        
        optimal_hours = []
        
        for hour_str, stats in hourly_analysis['hourly_statistics'].items():
            # 条件チェック
            if (stats['total_trades'] >= min_trades and
                stats['win_rate'] >= min_win_rate and
                stats['profit_factor'] >= min_profit_factor):
                
                optimal_hours.append({
                    'hour': hour_str,
                    'statistics': stats,
                    'score': self._calculate_hour_score(stats)
                })
        
        # スコア順でソート
        optimal_hours.sort(key=lambda x: x['score'], reverse=True)
        
        # 連続する時間帯をグループ化
        time_windows = self._group_consecutive_hours(optimal_hours)
        
        return {
            'symbol': symbol,
            'criteria': {
                'min_trades': min_trades,
                'min_win_rate': min_win_rate,
                'min_profit_factor': min_profit_factor
            },
            'optimal_hours': optimal_hours[:10],  # トップ10
            'recommended_windows': time_windows,
            'trading_schedule': self._generate_trading_schedule(time_windows)
        }
    
    def _calculate_hour_score(self, stats: dict) -> float:
        """時間帯スコア計算"""
        # 複数指標の重み付き合計
        win_rate_score = stats['win_rate'] / 100 * 0.3
        profit_factor_score = min(stats['profit_factor'] / 2, 1.0) * 0.4
        avg_profit_score = max(stats['avg_profit_per_trade'] / 1000, 0) * 0.3
        
        return win_rate_score + profit_factor_score + avg_profit_score
    
    def _group_consecutive_hours(self, optimal_hours: list) -> list:
        """連続する時間帯のグループ化"""
        if not optimal_hours:
            return []
        
        windows = []
        current_window = [optimal_hours[0]]
        
        for i in range(1, len(optimal_hours)):
            current_hour = int(optimal_hours[i]['hour'].split(':')[0])
            prev_hour = int(optimal_hours[i-1]['hour'].split(':')[0])
            
            # 連続チェック（24時間回りも考慮）
            if (current_hour == (prev_hour + 1) % 24):
                current_window.append(optimal_hours[i])
            else:
                if len(current_window) >= 2:  # 2時間以上の窓のみ
                    windows.append(current_window)
                current_window = [optimal_hours[i]]
        
        # 最後の窓を追加
        if len(current_window) >= 2:
            windows.append(current_window)
        
        return windows
```

### API エンドポイント
```python
@app.get("/api/v1/analysis/market-sessions/{symbol}")
async def get_market_session_analysis(symbol: str, period_days: int = 365):
    """市場セッション分析"""
    
@app.get("/api/v1/analysis/hourly/{symbol}")
async def get_hourly_analysis(symbol: str, period_days: int = 365):
    """時間別分析"""
    
@app.get("/api/v1/analysis/weekday/{symbol}")
async def get_weekday_analysis(symbol: str, period_days: int = 365):
    """曜日別分析"""
    
@app.get("/api/v1/analysis/optimal-hours/{symbol}")
async def get_optimal_trading_hours(symbol: str):
    """最適取引時間取得"""
    
@app.get("/api/v1/analysis/economic-impact/{symbol}")
async def get_economic_impact_analysis(symbol: str):
    """経済指標影響分析"""
```

## 分析結果の可視化
- ヒートマップ（時間×曜日の勝率）
- 市場セッション別パフォーマンスチャート
- 経済指標前後の価格変動グラフ
- 最適取引時間帯の推奨スケジュール

## 見積もり
**3日**

## 依存関係
- チケット003: データベース設計実装

## 完了条件
- [×] 市場セッション分析が動作する
- [×] 時間別・曜日別分析が動作する
- [×] 経済指標連携が動作する
- [×] 最適時間帯検出が動作する
- [×] 分析結果APIが動作する